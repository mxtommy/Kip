import { DestroyRef, Injectable, OnDestroy, inject } from '@angular/core';
import { EMPTY, Observable, Subject } from 'rxjs';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { DataService } from './data.service';
import { IPathUpdateEvent } from '../interfaces/app-interfaces';

export type PathDiscoveryToken = string;
export type PathChangeType = 'add' | 'remove';
export type PathContextType = 'self' | 'atons' | 'vessels';

export interface PathChange {
  type: PathChangeType;
  path: string;
}

export interface PathDiscoveryCriteria {
  /** Optional identifier used when generating tokens for this criteria. If unspecified, it will be autogenerated */
  id?: string;
  /**
    * Glob filter patterns to match against full paths (e.g. vessels.&#42;.navigation.&#42;, self.navigation.position.&#42;).
    * At least one criteria (filter or guard) must be provided.
   */
  patterns: string[];
  /**
   * Optional guard for context types. Supported types: 'self', 'vessels', 'atons'.
   * If not provided, no context filtering is applied.
   */
  contextTypes?: PathContextType[];
  /**
   * Optional guard for path-only prefixes with startsWith (the portion after the context type segment).
   * Ex: prefix 'identification.' would match 'self.identification.mmsi' or 'atons.urn:mrn:imo:mmsi:123456789.identification.name'.
   * If not provided, no path prefix filtering is applied.
   */
  pathPrefixes?: string[];
  /**
   * Optional guard for path-only suffixes checked against the path part (after the context type segment).
   * Ex: suffix '.mmsi' would match 'vessels.urn:mrn:imo:mmsi:123456789.identification.mmsi'.
   * If not provided, no path suffix filtering is applied.
   */
  pathSuffixes?: string[];
}

interface CompiledPathDiscoveryCriteria extends PathDiscoveryCriteria {
  /** Precompiled matchers and guards used internally to avoid repeated setup cost. */
  compiled: {
    /** Precompiled glob-to-regex patterns. */
    patterns: RegExp[];
    /** Cached context type guards for fast checks. */
    contextTypes: PathContextType[];
    /** Cached path prefix guards for fast startsWith checks. */
    prefixGuards: string[];
    /** Cached path suffix guards for fast endsWith checks. */
    suffixGuards: string[];
  };
}

interface PathDiscoveryRegistration {
  criteria: CompiledPathDiscoveryCriteria;
  matches: Set<string>;
  changes$: Subject<PathChange>;
}

@Injectable({
  providedIn: 'root'
})
export class PathDiscoveryService implements OnDestroy {
  private readonly data = inject(DataService);
  private readonly destroyRef = inject(DestroyRef);

  private readonly allPaths = new Set<string>();
  private readonly registrations = new Map<PathDiscoveryToken, PathDiscoveryRegistration>();

  constructor() {
    this.data.observePathUpdates()
      .pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe(event => this.applyPathUpdate(event));

    this.data.isResetService()
      .pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe(() => this.reset());
  }

  /**
   * Registers a new path discovery consumer. At least one criteria (pattern or guard) must be provided.
   * Returns a token used to query matches and listen for changes.
   *
   * IMPORTANT: Criteria guards are combined as AND across guard types, with OR inside each list.
   *
   * @param {PathDiscoveryCriteria} criteria Matching criteria (glob patterns + optional guards).
   * @returns {PathDiscoveryToken} Token used for subsequent calls (changes, activePaths, unregister).
   * @throws Error if no criteria (patterns or guards) are provided.
   */
  public register(criteria: PathDiscoveryCriteria): PathDiscoveryToken {
    this.assertHasCriteria(criteria);
    const token = this.createToken(criteria.id);
    const compiled = this.compileCriteria(criteria);
    const matches = new Set<string>();

    for (const path of this.allPaths) {
      if (this.matchesCriteria(path, compiled)) {
        matches.add(path);
      }
    }

    this.registrations.set(token, {
      criteria: compiled,
      matches,
      changes$: new Subject<PathChange>()
    });

    return token;
  }

  /**
   * Unregisters a discovery token and completes its change stream.
   * @param {PathDiscoveryToken} token Token returned by {@link register}.
   * @returns void
   */
  public unregister(token: PathDiscoveryToken): void {
    const registration = this.registrations.get(token);
    if (!registration) return;
    registration.changes$.complete();
    this.registrations.delete(token);
  }

  /**
   * Returns an observable of add/remove events for a given token.
   * @param {PathDiscoveryToken} token Token returned by {@link register}.
   * @returns Observable stream of add/remove path events.
   */
  public changes(token: PathDiscoveryToken): Observable<PathChange> {
    return this.registrations.get(token)?.changes$.asObservable() ?? EMPTY;
  }

  /**
   * Returns the active matched paths for the provided token.
    * @param {PathDiscoveryToken} token Token returned by {@link register}.
    * @returns Readonly set of matched full paths.
   */
  public activePaths(token: PathDiscoveryToken): ReadonlySet<string> {
    return this.registrations.get(token)?.matches ?? new Set<string>();
  }

  /**
   * Returns a simple list of currently known paths that match the criteria.
    * @param {PathDiscoveryCriteria} criteria Matching criteria (glob patterns + optional guards).
    * @returns Array of matching full paths.
   * @throws Error if no criteria (patterns or guards) are provided.
   */
  public match(criteria: PathDiscoveryCriteria): readonly string[] {
    this.assertHasCriteria(criteria);
    const compiled = this.compileCriteria(criteria);
    return Array.from(this.allPaths).filter(path => this.matchesCriteria(path, compiled));
  }

  private applyPathUpdate(event: IPathUpdateEvent): void {
    const fullPath = event?.fullPath;
    if (!fullPath) return;

    if (event.update?.value === null) {
      //TODO: fix delete on timeout
      //this.removePath(fullPath);
      return;
    }

    this.addPath(fullPath);
  }

  private addPath(path: string): void {
    if (this.allPaths.has(path)) return;
    this.allPaths.add(path);

    for (const registration of this.registrations.values()) {
      if (this.matchesCriteria(path, registration.criteria)) {
        registration.matches.add(path);
        registration.changes$.next({ type: 'add', path });
      }
    }
  }

  private removePath(path: string): void {
    if (!this.allPaths.delete(path)) return;

    for (const registration of this.registrations.values()) {
      if (registration.matches.delete(path)) {
        registration.changes$.next({ type: 'remove', path });
      }
    }
  }

  private reset(): void {
    for (const registration of this.registrations.values()) {
      for (const path of registration.matches) {
        registration.changes$.next({ type: 'remove', path });
      }
      registration.matches.clear();
    }
    this.allPaths.clear();
  }

  private compileCriteria(criteria: PathDiscoveryCriteria): CompiledPathDiscoveryCriteria {
    const patterns = criteria.patterns?.length ? criteria.patterns : [];
    return {
      ...criteria,
      patterns,
      compiled: {
        patterns: patterns.map(pattern => this.globToRegex(pattern)),
        contextTypes: criteria.contextTypes ?? [],
        prefixGuards: criteria.pathPrefixes ?? [],
        suffixGuards: criteria.pathSuffixes ?? []
      }
    };
  }

  private matchesCriteria(fullPath: string, criteria: CompiledPathDiscoveryCriteria): boolean {
    const compiled = criteria.compiled;

    const contextType = this.getContextType(fullPath);

    if (compiled.contextTypes.length && (!contextType || !compiled.contextTypes.includes(contextType))) {
      return false;
    }

    const pathPart = this.getPathPart(fullPath, contextType);

    if (compiled.prefixGuards.length && !compiled.prefixGuards.some(prefix => pathPart.startsWith(prefix))) {
      return false;
    }

    if (compiled.suffixGuards.length && !this.matchesSuffix(pathPart, compiled.suffixGuards)) {
      return false;
    }

    if (!compiled.patterns.length) return true;
    return compiled.patterns.some(regex => regex.test(fullPath));
  }

  private getPathPart(fullPath: string, contextType: PathContextType | null): string {
    if (contextType === 'self') {
      const idx = fullPath.indexOf('.');
      if (idx === -1) return fullPath;
      return fullPath.slice(idx + 1);
    }

    if (contextType === 'vessels' || contextType === 'atons') {
      const prefix = `${contextType}.urn:mrn:imo:mmsi:`;
      if (!fullPath.startsWith(prefix)) return fullPath;
      const idx = fullPath.indexOf('.', prefix.length);
      if (idx === -1) return '';
      return fullPath.slice(idx + 1);
    }

    const idx = fullPath.indexOf('.');
    if (idx === -1) return fullPath;
    return fullPath.slice(idx + 1);
  }

  private getContextType(fullPath: string): PathContextType | null {
    if (fullPath.startsWith('self.')) return 'self';
    if (fullPath.startsWith('vessels.urn:mrn:imo:mmsi:')) return 'vessels';
    if (fullPath.startsWith('atons.urn:mrn:imo:mmsi:')) return 'atons';
    return null;
  }

  private globToRegex(pattern: string): RegExp {
    const escaped = pattern.replace(/[-/\\^$+?.()|[\]{}]/g, '\\$&');
    const regex = '^' + escaped.replace(/\*/g, '.*').replace(/\?/g, '.') + '$';
    return new RegExp(regex);
  }

  private matchesSuffix(pathPart: string, suffixes: string[]): boolean {
    if (!suffixes.length) return true;
    const lastDot = pathPart.lastIndexOf('.');
    const suffixCandidate = lastDot === -1 ? `.${pathPart}` : pathPart.slice(lastDot);
    return suffixes.some(suffix => pathPart.endsWith(suffix) || suffixCandidate === suffix);
  }

  private createToken(id?: string): PathDiscoveryToken {
    const base = id ?? 'token';
    let token = `${base}-${Math.random().toString(36).slice(2, 10)}`;
    while (this.registrations.has(token)) {
      token = `${base}-${Math.random().toString(36).slice(2, 10)}`;
    }
    return token;
  }

  private assertHasCriteria(criteria: PathDiscoveryCriteria): void {
    const hasPatterns = Array.isArray(criteria.patterns) && criteria.patterns.length > 0;
    const hasContext = Array.isArray(criteria.contextTypes) && criteria.contextTypes.length > 0;
    const hasPrefix = Array.isArray(criteria.pathPrefixes) && criteria.pathPrefixes.length > 0;
    const hasSuffix = Array.isArray(criteria.pathSuffixes) && criteria.pathSuffixes.length > 0;

    if (!hasPatterns && !hasContext && !hasPrefix && !hasSuffix) {
      throw new Error('PathDiscoveryService.register requires at least one criteria (pattern or guard).');
    }
  }

  ngOnDestroy(): void {
    for (const registration of this.registrations.values()) {
      registration.changes$.complete();
    }
    this.registrations.clear();
    this.allPaths.clear();
  }
}
